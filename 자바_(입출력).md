Java 사용설명서(입출력)
=======================

### 1. `Scanner` : 친절한 편의점 직원

`Scanner`는 가장 쓰기 편한 도구로 입력하는 데이터를 알아서 정수, 실수, 문자열로 통역해서 건네줌

- 특징 : `nextInt(), nextDouble()`처럼 데이터 타입을 자동으로 변환해주는 기능이 강력
- 단점 : 속도가 느림. 데이터를 읽을 때 정규식을 사용해 꼼꼼히 검사하기 때문
- 비유 : 내가 "10원짜리 줘"라고 하면 동전 통에서 10원을 골라서 딱 주는 <b>친절한 편의점 직원</b> 느낌

### 2. `BufferedReader` : 빛의 속도 도매 창고

`BufferedReader`는 오직 속도에 올인한 도구로 큼직한 바구니(버퍼)를 들고 가서 한 줄 통째로 쏟아 부어 가져옴

- 특징 : 매우 빠름. 백준 같은 알고리즘 사이트에서 입력 데이터가 많을 때 필수
- 단점 : 무조건 문자열(`String`)로만 읽어옴. 숫자로 쓰려면 직접 변환(`Integer.parseInt()`)해야 함. 예외 처리(`throws IOException`)도 직접 해야 해서 코드가 복잡
- 비유 : 물건을 하나씩 확인 안 하고 박스째로 트럭에 싣고 오는 <b>도매 창고</b>같음.

### 3. `StringBuilder` : 자유로운 조립 칠판

앞선 두 개가 입력 도구라면, `StringBuilder`는 출력할 데이터를 만들 때 쓰는 도구

- 특징 : 문자열을 계속 더해도(`append`) 메모리를 낭비하지 않고 아주 빠르게 작동
- 왜 쓰나? : 자바의 일반 `String`은 한 번 만들면 수정이 안 됨. `str += '별'`을 할 때마다 사실 매번 새로운 문자열을 만드는 비효율이 생김. `StringBuilder`는 하나를 만들어 두고 <b>계속 덧붙일 수 있음</b>

### 4. 비교하기


| 구분      | `Scanner`                | `BufferedReader`            | `StringBuilder`                |
| --------- | ------------------------ | --------------------------- | ------------------------------ |
| 주 역할   | 데이터 입력 (입사형)     | 데이터 입력 (속도형)        | 데이터 조립 (출력용)           |
| 속도      | 느림 (검사 과정이 많음)  | <b>매우 빠름 (통째로 읽음)  | <b>매우 빠름 (메모리 절약)     |
| 난이도    | 쉬움                     | 조금 복잡<b>(예외처리 필요) | 쉬움                           |
| 사용 시점 | 입력이 적고 편하게 짤 때 | 입력이 수만 개 이상일 때    | 반복문 안에서 문자열을 합칠 때 |

### 세 개를 한 번에 쓰는 실전 코드

<details>
<summary>실전 코드</summary>

<div markdown="1">

```java
import java.util.*;
import java.io.*;

public class Class1 {
    public static void main(String[] args) throws IOException {
        // 1.bufferedreader로 빠르게 읽어오기
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        // 2. stringbuilder로 출력할 내용 미리 조합
        StringBuilder sb = new StringBuilder();
      
        String input = br.readLine();
        int n = Integer.parseInt();
      
        for (int i=0; i<n; i++) {
            sb.append(i).append("번 손님\n");
        }
        // 3. 마지막에 한 번만 출력! (System.out 여러번 보다 훨씬 빠름)
        System.out.println(sb.toString());
    }
}
```

</div>
</details>


### 5. `StringTokenizer` 문자열 조절기

<details>
<summary>StringTokenizer 설명</summary>

<div markdown="1">

문자열을 우리가 원하는 기준에 따라 <b>토막(`Token`)</b>으로 썰어주는 요긴한 도구

1. 토큰이란?`StringTokenizer`에서 말하는 '토큰'은 <b>더 이상 쪼갤 수 없는 가장 작은 단위</b>ex) `"10 20 30"`문자열

   - `"10"` -> 토큰 1
   - `"20"` -> 토큰 2
   - `"30"` -> 토큰 3
2. 왜 `String.split()` 대신 쓸까?자바에는 문자열을 자르는 `split()`이라는 메서드가 있긴함.백준 같은 알고리즘 문제에서는 `StringTokenizer`를 훨 많이 씀

   - 속도(성능) : `split()`은 복잡한 규칙(정규식)을 사용해 자르기 때문에 느림
     `StringTokenizer`는 단순한 구분자(공백, 쉼표 등)에 따라 빛의 속도로 썰어버림
   - 효율성 : `split()`은 자른 결과물을 모두 배열에 담아두어 메모리를 많이 쓰지만
     `StringTokenizer`는 필요할 때마다 하나씩 `nextToken()`으로 꺼내 쓰기 때문에 메모리 절약
3. 핵심 사용법 (3총사)

| 메서드               | 역할                                  |
|-------------------|-------------------------------------|
| `nextToken()`     | 다음 조각(토큰)을 하나 꺼내옴 (꺼내면 창고에서 사라짐)    |  
| `hasMoreTokens()` | 아직 창고에 꺼낼 조각이 남아있는지 확인 (true/false) |
| `countTokens()`    | 현재 창고에 남아있는 조각의 총 개수를 알려줌           |

4. 작동 방식 : "화살표(포인터)의 이동"  
`StringTokenizer`안에는 현재 어디를 읽고 있는지 가리키는 화살표(포인터)가 있음
   1. 처음 생성하면 포인터는 첫 토큰을 가리킴
   2. `nextToken()`을 부르면 포인터가 가리키는 값을 던져주고, 포인터를 다음으로 옮김
   3. 포인터가 끝까지 가서 더 이상 값이 없는데 `nextToken()`을 호출하면 -> 에러(`NoSuchElementException`)발생
</div>
</details>

<details>
<summary>StringTokenizer 주의사항</summary>

<div markdown="1">

1. st를 두번 선언할 수 없음
- 재선언 (에러 발생) : "이미 `st`라는 이름표가 있는데 왜 또 만듬?"
    ```java
    StringTokenizer st = new StringTokenizer(br.readLine()); // 선언
    StringTokenizer st = new StringTokenizer(br.readLine()); // 에러 이름 중복
    ```
- 재할당 : "기존 `st`는 그대로 쓰고, 내용물만 다음 줄로 바꿈"
    ```java
    StringTokenizer st = new StringTokenizer(br.readLine()); // 선언
    st = new StringTokenizer(br.readLine()); // 새로운 객체로서 재할당
    ```
### `st`는 두 개의 값이 동시에 존재할 수 없음 !!  
1. 덮어쓰기 (Overwriting) : 1번 창고  
자바의 변수는 "오직 하나의 주소"만 가질 수 있음  
- 1단계(`st`선언) : `st`라는 이름표가 1번 창고(첫 줄 데이터)를 가리킴
- 2단계(재할당) : `st = new StrinTokenizer(...)`를 실행한 순간,`st` 이름표는 1번 창고과의 연결을 끊고 새로운 2번 창고를 설계
2. `nextToken()`은 창고 안에서만 동작  
   `nextToken()`의 포인터는 한 `st`내 에서만 동작하므로 재 할당된 `st`에는 다른 포인터가 들어가므로 이미 끝난 `st`에서 `nextToken()`을 호출해도 스스로 2번 창고로 넘어가지 않음
3. 요약

| 시점                    |`st`가 가리키는 대상| 이전 데이터의 운명       |   
|-----------------------|------------|------------------|   
| 첫 `new`이후             | 첫 창고(6개) | -                | 
| `nextToken()`6번 호출 이후 | 첫 창고 (전부 꺼냄) | 창고가 비었지만 이름은 그대로 |
| 두 번째 `new`이후          | 두 번째 창고 | 첫 창고 파괴(삭제)      |
</div>
</details>