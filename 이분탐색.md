이분 탐색 알고리즘
=

이분탐색(Binary Search)은 알고리즘에서 가장 유명하고 강력한 기법 중 하나

## 1. 핵심 비유 : "업다운 게임"
1~100 까지의 숫자 중 하나를 생각했고, 그 숫자를 맞춰야 함  
순서대로 1이야? 2야? 3? 하고 묻는다면, 최악의 경우 100번 물어봐야함 (이걸 순차탐색)

하지만 50이야? 라고 물어보면 
- 친구가 "UP이야" 라고 한다면 1~50은 버려도 됨 -> 다시 중간인 75를 물어봄
- "Down"이라고 한다면 50~100은 버리고 -> 25를 물어봄 

이렇게 질문할 때마다 남은 후보의 절반씩 잘라내며 버리는 방식을 "이분 탐색" 이라고 함

## 2. 이분 탐색의 3가지 핵심 요소
해당 범위를 관리하기 위해서 3개의 변수 포인트를 작성
- `left`(왼쪽 끝) : 현재 탐색하는 범위의 시작 점
- `right`(오른쪽 끝) : 현재 탐색하는 범위의 끝 점
- `mid`(중간점) : `left`와 `right`의 딱 중간 `(left + right) / 2`

탐색 과정
1. `mid`위치의 숫자를 확인
2. 내가 찾는 숫자보다 `mid`가 작으면 (업) -> `left`를 `mid+1`로 옮겨서 오른쪽 절반 확인
3. 내가 찾는 숫자보다 `mid`가 크면 (다운) -> `right`를 `mid-1`로 옮겨서 왼쪽 절반 확인

## 3. 절대 잊지 말아야 할 "단 하나의 필수조건"
"데이터는 반드시 오름차순으로 정렬이 되어있어야 한다"  
항상 탐색 전 `Arrays.sort()`를 먼저

## 4. 해당 알고리즘이 빠른 이유
데이터가 10만개 있다고 가정
- 순차탐색 : 최악의 경우 10만 번을 검사
- 이분 탐색 : 절반씩 버려서 단 17번 만에 데이터가 1개 남음 (2^17 = 131,072  

시간이 빡빡한 백준에서는 이분 탐색은 필수

## 예시 코드
```java
import java.util.*;
import java.io.*;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        // 1. 배열 A 입력받고 정렬하기
        int n = Integer.parseInt(br.readLine());
        int[] arr = new int[n];
        StringTokenizer st = new StringTokenizer(br.readLine());
        for (int i = 0; i < n; i++) {
            arr[i] = Integer.parseInt(st.nextToken());
        }

        Arrays.sort(arr); // ⭐ 이분 탐색의 필수 조건! 정렬!

        // 2. 찾아야 할 숫자들 입력받기
        int m = Integer.parseInt(br.readLine());
        st = new StringTokenizer(br.readLine());
        StringBuilder sb = new StringBuilder(); // 출력 속도를 위해 필수!

        // 3. M개의 숫자를 하나씩 꺼내서 업다운 게임(이분 탐색) 시작!
        for (int i = 0; i < m; i++) {
            int target = Integer.parseInt(st.nextToken()); // 우리가 찾아야 할 숫자

            // 이분 탐색 결과가 성공(true)이면 1, 실패(false)면 0을 저장
            if (binarySearch(arr, target)) {
                sb.append(1).append('\n');
            } else {
                sb.append(0).append('\n');
            }
        }
        System.out.println(sb);
    }

    // ⚔️ 이분 탐색 메서드 만들기 (핵심 로직!)
    public static boolean binarySearch(int[] arr, int target) {
        int left = 0;                  // 탐색 범위의 맨 왼쪽 끝 (인덱스 0)
        int right = arr.length - 1;    // 탐색 범위의 맨 오른쪽 끝 (마지막 인덱스)

        while (left <= right) {        // 왼쪽과 오른쪽이 뒤집히지 않을 때까지 반복
            int mid = (left + right) / 2; // 중간 위치 콕 찌르기!

            if (arr[mid] == target) {
                return true; // 찾았다! 정답!
            } else if (arr[mid] < target) {
                // 중간값보다 찾는 숫자가 더 크면? -> "업(Up)!" 
                // 왼쪽 절반을 버리고, 범위를 오른쪽으로 좁힘
                left = mid + 1;
            } else {
                // 중간값보다 찾는 숫자가 더 작으면? -> "다운(Down)!"
                // 오른쪽 절반을 버리고, 범위를 왼쪽으로 좁힘
                right = mid - 1;
            }
        }
        return false; // 끝까지 쪼갰는데도 없으면 실패...
    }
}
```