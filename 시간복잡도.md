시간복잡도
==

### 1. 시간복잡도란?  
  - 입력크기(`n`)이 커질 때  
  내 코드의 실행 횟수가 얼마나 증가하는지를 나타내는 것
  - "이 코드가 얼마나 느려질까" 를 예측하는 도구


### 2. `Big-O` 표기법
  - 시간복잡도는 보통 `O( )`으로 표기
  - ex)
    - `O(1)` : 항상 일정한 시간
    - `O(n)` : 입력의 크기만큼 증가
    - `O(n²)` : 입력의 제곱만큼 증가
    - `O(log n)` : 로그 증가 (반씩 줄어드는 구조)
    

### 3. 가장 많이 나오는 시간복잡도 유형
<details>
<summary>유형</summary>

<div markdown="1">

#### 1. 상수시간 `O(1)`
```java
int a = arr[0];
```
- 입력 크기에 상관없이 한 번만 실행

#### 2. 1중 반복문 `O(n)`
```java
for (int i=0; i<n; i++) {
    // 실행문
        }
```
- `n`번 실행

#### 3. 2중 반복문 `O(n²)`
```java
for (int i=0; i<n; i++) {
        for (int j=0; j<n; j++) {
        // 실행문
        }
    }
```
- `n x n` 번 실행

#### 4. 절반씩 줄어드는 경우 `O(log n)`
```java
while (n > 1) {
    n /= 2;
}
```
- 매번 절반으로 줄어듬
  - 이진 탐색
  - 분할 정복 

</div>
</details>

### 4. 입력 크기별 허용 시간복잡도 감각

| 입력 크기            | 허용 가능 시간복잡도          |  
|------------------|----------------------|  
| `N <= 1,000`     | `O(n²)` o            |
| `N <= 100,000`   | `O(n²)` x / `O(n)` o |
| `N <= 1,000,000` | `O(n log n)` o       |
| `N >= 10^7 `     | `O(n)` 도 위험          |

---
#### 5. 시간복잡도 계산 방법
1. 가장 많이 도는 반복문 찾기
2. 중첩 구조인지 확인
3. 입력 제한(`N`)을 보기
4. 대략적인 실행 횟수를 계산
- ex
  - N = 100,000
  - 2중 반복문 = 100,000² = 10,000,000,000
  - 시간 초과 가능성 높음


#### 6. 문제 풀이 후 체크리스트
- 반복문은 몇 겹인가
- 입력 크기 `N`은 얼마인가
- 대략 몇 번 실행되는가
- 더 줄일 방법은 없는가


#### 7. 코드 끝 추가할 내용
문제 풀이 후 맨 아래에 해당 내용 추가
```Markdown
## 문제: --- 번 
- 입력크기 : n <= 100,000
- 사용 알고리즘 : 이중 반복문
- 시간 복잡도 : O(n²)
- 예상 실행 횟수 : 약 10^10 -> 개선 필요
```