자바 팁 !
===

## 1. 자릿수 더하는 공식  
- `while`문을 이용한 방식으로 자바에서 숫자를 다룰 때 정말 많이 쓰임  
   - `number % 10` : 일의 자리 숫자를 가져옴 -> `123%10 = 3`  
   - `number / 10` : 일의 자리 제거 + 숫자를 한 칸 줄임 -> `123/10 = 12`
- 검색 범위 최적화  
  1부터 돌 필요 없이 최대값 각 자릿수의 합의 최대값만큼 빼고 시작해도 됨
  - ex) N이 3자리수이면, 각 자릿수 합 최대($9*3=27$)를 넘길 수 없음
  - 따라서 `i`의 시작점을 `m-27`로 해도 결과는 똑같음, 속도 빨라짐(n이 작을 때, 음수가 되지 않도록 주의)

## 2. 배열에 넣을 때 오류를 방지하는 방법
- `NoSuchElementException`오류   
  `Tokenizer`가 비어있는데 계속 꺼내라고 해서 발생한 오류
  - 발생 이유 :
    - 코드의 입력이 `5 6 7 8 9`가 아닌 `5 6 \n 7 8 9`처럼 한 줄로 오는게 아닐 경우  
      `st = new StringTokenizer(br.readLine());`은 딱 한 줄만 읽기 때문에 숫자가 부족하면 다음 줄을 읽지 않고 오류를 발생시킴
  - 해결 방법 : "없으면 다음 줄 읽어오기"
    ```java
    import java.io.*;
    import java.util.*;
    public class Main {
        public static void main(String[] args) throws IOException {
            BufferedReader br = new BufferedReader(System.in);
            StringTokenizer st = new StringTokenizer(br.readLine());
            // 토큰이 없으면 새 줄을 읽어서 채움 (안전)
            // 다음 줄 읽을 준비
            st = new StringTokenizer(br.readLine());
            for (int i=0; i<n; i++) {
                // 1. 현재 줄에 남은 토큰이 없다면 ? (엔터 또느 줄 바꿈이 있었나)
                while (!st.hasMoreTokens()) {
                    // 2. 다음 줄을 새롤 읽어서 st에 넣음
                    st = new StringTokenizer(br.readLine());
                }
                // 3. 안전하게 꺼냄
                numArr[i] = Integer.parseInt(st.nextToken());
            }
        }   
    }
    ```
  - 해당 코드가 멈추는 이유 : 
    - 정상 종료 : 약속한 N개의 숫자를 모두 배열에 다 채웠을 때 (`for`문 종료)
    - 비정상 종료(에러) : N개를 채워야 하는데, 더 이상 읽을 줄이 아예 없을 때(입력 파일 끝, EOF)-> 이때 `br.readLine()`이 `null`을 반환

## 3. 함수 다이어트(람다식)
자바 8부터 도입된 기능으로, 코드를 매우 짧고 간결하게 만들어주는 문법,  
알고리즘에서 정렬이나 조건 검사를 할 때 필수적으로 쓰임
- 일반적인 함수 (익명 내부 클래스)  
  - 자바에서 이름 없는 함수를 일회용으로 쓸려면, 인터페이스를 부르고 메서드를 오버라이딩하는 복잡한 과정을 거침
  ```java
  interface Calculator {
    int sum(int a, int b) {
    }
  }
  Calculator cal = new Calculator() {
    @Override
    public int sum(int a, int b) {
        return a+b;
    }
  }
  ```
- 람다식 (Lambda)  
딱 한 줄이면 끝
  ```java
  Calculator cal = (a,b) -> a+b;
  ```
  
  - 자바 컴파일러는 똑똑해서 웬만한 건 생략해도 알아들음
    1. 매개변수 타입 생략 가능 : `(int a) -> ...` 대신 `(a) -> ...`
    2. 괄호 생략 가능 (매개변수가 1개일 떄) : `(a) -> ...` 대신 `a -> ...`
    3. 중괄호,return 생략 가능 (한 줄일 때) : 
       - `x -> {return x * x; }` (x)
       - `x -> x * x` (o)

  - 주의할 점
    - 함수형 인터페이스 : 람다식은 추상 메서드가 딱 1개만 있는 인터페이스(ex : `Comparator`, `Runnable`)에서만 쓸 수 있음
    - 디버깅 : 코드가 너무 함축적이라, 나중에 에러가 났을 때 어디서 틀렸는지 찾기가 조금 어려울 수 있음
    - 재귀호출 : 람다식 내부에서 자기 자신을 부르는 재귀 호출을 까다로움 (팩토리얼 등)
- 예시 코드
```java
import java.util.Arrays;

public class Main {
  public static void main(String[] args) {
    String[] arr = {"but", "i", "wont", "hesitate", "no", "more", "no", "more", "it", "cannot"};

    // 아까 배운 람다식 출동!
    Arrays.sort(arr, (s1, s2) -> {

      // 1. 길이가 같다면? (사전순 정렬)
      if (s1.length() == s2.length()) {
        return s1.compareTo(s2);
      }

      // 2. 길이가 다르면? (짧은 순서대로 정렬)
      return s1.length() - s2.length();
    });

    // 출력해보기
    for (String s : arr) {
      System.out.println(s);
    }
  }
}
```